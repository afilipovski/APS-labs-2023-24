## Задача 1

## Задача 2
За да провереме дали таговите во модифицираниот XML код се правилно вгнездени, ќе ja користиме податочната структура `Stack`. Притоа, сите линии код кои не се отворен таг или затворен таг се отстрануваат бидејќи нема потреба да се разгледуваат.

Идејата на решението со стек е да се разрешат XML затворачките тагови што е можно побрзо. За таа цел, во стекот ги ставаме сите валидни отварачки тагови. Кога ќе наидеме на првиот затворачки таг, истиот мора да соодветствува на последниот отворен таг кој што бил внесен во стекот. Во спротивно XML кодот е невалидн.

Да ја разгледаме идејата преку пример:
```
[tag1]
	[tag2]
		[tag3]
		[/tag3]
	[/tag2]
[/tag1]
```
Пример 1. Правилно вгнезден модифициран XML код.

Во стек ги додаваме сите отварачки тагови на кои ќе наидеме, па до одреден момент во стекот имаме
```
// push all opening tags to the stack
stack = {}
stack = {"[tag1]"}  
stack = {"[tag1]", "[tag2]"}
stack = {"[tag1]", "[tag2]", "[tag3]"}  
```
Кога ќе наидеме на првиот затворачки таг, истиот мора да го затвара последниот отворачки таг во стекот. Ако е тоа така, се отстранува отворачкиот таг од стекот бидејќи тагот е правилно вгнезден, а програмата продолжува како тие тагови да не постоеле. 
```
// closing tag [/tag3] found...

// check if it closes the last pushed opening tag...
// if yes, remove the tag
stack = {"[tag1]", "[tag2]"}

// if no, the XML code is not valid
```
После отстранување на дадениот таг `[tag3][/tag3]`, програмата всушност работи со поедноставена верзија на проблемот на верификација дали таговите се правилно вгнездени, односно како да бил разгледуван проблемот
```
[tag1]
	[tag2]
	[/tag2]
[/tag1]
```
Ако отстранување на тагот не беше можно, тогаш XML кодот не би бил валиден. Оваа процедура се повторува се додека не се изминат сите тагови без проблем и стекот е целосно испразнет.

Временска сложеност: $O(n)$
Мемориска сложеност: $O(n)$

## Задача 3
