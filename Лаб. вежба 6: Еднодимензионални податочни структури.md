## Задача 1
Постфикс начинот на пресметување изрази е исто така познат под името Reverse Polish Notation, и се користи во програмските јазици кои се основани на [стек-ориентираната парадигма](https://en.wikipedia.org/wiki/Stack-oriented_programming). Според тоа, очигледно е дека оваа задача ќе ја решиме со употреба на еден `Stack`.

Корисно е низата знаци која ја добиваме на влез на методата да ја претвориме во `String`, па потоа да го разделиме на токени со `.split(" ")`. Така нема да треба сами да се справуваме со повеќецифрените броеви, туку ќе користиме готова метода.

Токенизираната низа ја изминуваме, и секогаш кога ќе сретнеме број го додаваме на стекот од операнди. Кога ќе сретнеме оператор, ги вадиме најгорните 2 броја-операнди од стекот (b и a, едноподруго), и ја извршуваме операцијата `a+b`, `a-b`, `a*b`, или `a/b`. Добиениот резултат го додаваме повторно на стекот, за да го искористиме во другите пресметки кои следат.

На крајот од целиот процес ни останува еден број во стекот кој е конечниот резултат.

За вежба, размислете како би ја модифицирале задачава за да работи со префикс нотација, каде во изразот прв се јавува операторот, а потоа операндите. Hint: ќе ни треба уште еден стек.

Временска сложеност: $O(n)$ 
Мемориска сложеност: $O(n)$

## Задача 2
За да провереме дали таговите во модифицираниот XML код се правилно вгнездени, ќе ja користиме податочната структура `Stack`. Притоа, сите линии код кои не се отворен таг или затворен таг се отстрануваат бидејќи нема потреба да се разгледуваат.

Идејата на решението со стек е да се разрешат XML затворачките тагови што е можно побрзо. За таа цел, во стекот ги ставаме сите валидни отварачки тагови. Кога ќе наидеме на првиот затворачки таг, истиот мора да соодветствува на последниот отворен таг кој што бил внесен во стекот. Во спротивно XML кодот е невалидн.

Да ја разгледаме идејата преку пример:
```
[tag1]
	[tag2]
		[tag3]
		[/tag3]
	[/tag2]
[/tag1]
```
Пример 1. Правилно вгнезден модифициран XML код.

Во стек ги додаваме сите отварачки тагови на кои ќе наидеме, па до одреден момент во стекот имаме
```
// push all opening tags to the stack
stack = {}
stack = {"[tag1]"}  
stack = {"[tag1]", "[tag2]"}
stack = {"[tag1]", "[tag2]", "[tag3]"}  
```
Кога ќе наидеме на првиот затворачки таг, истиот мора да го затвора последниот отворачки таг во стекот. Ако е тоа така, се отстранува отворачкиот таг од стекот бидејќи тагот е правилно вгнезден, а програмата продолжува како тие тагови да не постоеле. 
```
// closing tag [/tag3] found...

// check if it closes the last pushed opening tag...
// if yes, remove the tag
stack = {"[tag1]", "[tag2]"}

// if no, the XML code is not valid
```
После отстранување на дадениот таг `[tag3][/tag3]`, програмата всушност работи со поедноставена верзија на проблемот на верификација дали таговите се правилно вгнездени, односно како да бил разгледуван проблемот
```
[tag1]
	[tag2]
	[/tag2]
[/tag1]
```
Ако отстранување на тагот не беше можно, тогаш XML кодот не би бил валиден. Оваа процедура се повторува се додека не се изминат сите тагови без проблем и стекот е целосно испразнет.

Временска сложеност: $O(n)$ 
Мемориска сложеност: $O(n)$

## Задача 3
