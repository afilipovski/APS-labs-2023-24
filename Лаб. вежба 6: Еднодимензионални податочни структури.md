## Задача 1
Постфикс начинот на пресметување изрази е исто така познат под името Reverse Polish Notation, и се користи во програмските јазици кои се основани на [стек-ориентираната парадигма](https://en.wikipedia.org/wiki/Stack-oriented_programming). Според тоа, очигледно е дека оваа задача ќе ја решиме со употреба на еден `Stack`.

Корисно е низата знаци која ја добиваме на влез на методата да ја претвориме во `String`, па потоа да го разделиме на токени со `.split(" ")`. Така нема да треба сами да се справуваме со повеќецифрените броеви, туку ќе користиме готова метода.

Токенизираната низа ја изминуваме, и секогаш кога ќе сретнеме број го додаваме на стекот од операнди. Кога ќе сретнеме оператор, ги вадиме најгорните 2 броја-операнди од стекот (b и a, едноподруго), и ја извршуваме операцијата `a+b`, `a-b`, `a*b`, или `a/b`. Добиениот резултат го додаваме повторно на стекот, за да го искористиме во другите пресметки кои следат.

На крајот од целиот процес ни останува еден број во стекот кој е конечниот резултат.

За вежба, размислете како би ја модифицирале задачава за да работи со префикс нотација, каде во изразот прв се јавува операторот, а потоа операндите. Hint: ќе ни треба уште еден стек.

Временска сложеност: $O(n)$ \
Мемориска сложеност: $O(n)$

## Задача 2
За да провереме дали таговите во модифицираниот XML код се правилно вгнездени, ќе ja користиме податочната структура `Stack`. Притоа, сите линии код кои не се отворен таг или затворен таг се отстрануваат бидејќи нема потреба да се разгледуваат.

Идејата на решението со стек е да се разрешат XML затворачките тагови што е можно побрзо. За таа цел, во стекот ги ставаме сите валидни отварачки тагови. Кога ќе наидеме на првиот затворачки таг, истиот мора да соодветствува на последниот отворен таг кој што бил внесен во стекот. Во спротивно XML кодот е невалидн.

Да ја разгледаме идејата преку пример:
```
[tag1]
	[tag2]
		[tag3]
		[/tag3]
	[/tag2]
[/tag1]
```
Пример 1. Правилно вгнезден модифициран XML код.

Во стек ги додаваме сите отварачки тагови на кои ќе наидеме, па до одреден момент во стекот имаме
```
// push all opening tags to the stack
stack = {}
stack = {"[tag1]"}  
stack = {"[tag1]", "[tag2]"}
stack = {"[tag1]", "[tag2]", "[tag3]"}  
```
Кога ќе наидеме на првиот затворачки таг, истиот мора да го затвора последниот отворачки таг во стекот. Ако е тоа така, се отстранува отворачкиот таг од стекот бидејќи тагот е правилно вгнезден, а програмата продолжува како тие тагови да не постоеле. 
```
// closing tag [/tag3] found...

// check if it closes the last pushed opening tag...
// if yes, remove the tag
stack = {"[tag1]", "[tag2]"}

// if no, the XML code is not valid
```
После отстранување на дадениот таг `[tag3][/tag3]`, програмата всушност работи со поедноставена верзија на проблемот на верификација дали таговите се правилно вгнездени, односно како да бил разгледуван проблемот
```
[tag1]
	[tag2]
	[/tag2]
[/tag1]
```
Ако отстранување на тагот не беше можно, тогаш XML кодот не би бил валиден. Оваа процедура се повторува се додека не се изминат сите тагови без проблем и стекот е целосно испразнет.

Временска сложеност: $O(n)$ \
Мемориска сложеност: $O(n)$

## Задача 3

### Примарно решение

За решавање на задачата ќе ја користиме податочната структура Ред (Queue). За секој вид документ ќе имаме посебна редица, при што секоја од нив ќе има ниво на приоритет (најголем приоритет -> прв ќе биде услужен):

1. Ред за лична карта (приоритет 3)
2. Ред за пасош (приоритет 2)
3. Ред за возачка (приоритет 1)

За секој од редовите ќе повикуваме човек, доколку тој ред има најголем приоритет од редовите каде чека барем 1 човек. Откога ќе му дадеме документ на човекот кој е прв од избраната редица, ќе направиме една од 2 можни опции:

1. Ќе го префрлиме во ред со најголем приоритет во кој тој треба да чека 
2. Ќе му го испечатиме името доколку завршил со сите документи.

Ова ќе го правиме се додека сите редици не се празни.

Временска сложеност: $O(n)$\
Мемориска сложеност: $O(n)$

### Решение со една редица (PriorityQueue)

Приоритет на личност ќе се определи на следниот начин:

1. Според приоритет на најбитниот документ
2. Доколку е ист приоритетот, според времето во кој влегол во редот за сегашниот документ (вредноста се менува после подигнување на секој документ)

Се враќа секој човек во редот доколку треба да се уште треба да подигне документ. Ако завршил, се печати неговото име.

Временска сложеност: $O(n \log(n))$\
Мемориска сложеност: $O(n)$
