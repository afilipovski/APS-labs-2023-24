## Задача 1
Имаме двојно поврзана листа од војници, и треба во неа да ги превртиме сите кои се наоѓаат меѓу тој со ID a *(војникот А)* и тој со ID b *(војникот Б)*. Задачава би се решила релативно лесно кога би можеле да користиме insertBefore, insertAfter и слични операции. Но, според барањето, мора мануелно да итерираме низ листата и да ги менуваме pred и succ референците. 

Може да започнеме со изминување на листата и зачувување на 4 битни референци: војникот А, неговиот **сосед**/претходник, војникот Б, и неговиот **сосед**/следбеник. На сликата се обележани во жолто.

![[Pasted image 20231104203531.png]]
*слика 1.*

Потоа, бидејќи сакаме сите елементи во опсегот меѓу А и Б да бидат превртени, може да итерираме меѓу тие два елементи, и да ги swap-уваме врските pred и succ за секој елемент:

Hint: кога ќе итерираме ќе ги менуваме pred и succ. Со тоа, за да пристапиме кон следниот елемент ќе треба да назначиме curr=curr.pred во секоја итерација, иако на прв поглед изгледа неинтуитивно. 

![[Pasted image 20231104203816.png]]
*слика 2.*

Врските обележани во црвено ќе покажуваат кон некој јазол надвор од оваа „подлиста“, но тоа не е битно, како што ќе видиме подоцна.

Сега треба вака превртената подлиста да ја вметнеме во поголемата. Односно, соседот на А (нема елемент пред А, така што ќе менуваме во first референцата од листата), да го поврземе со елементот Б - и соседот на Б (јазолот со елемент 6), да го поврземе со А.

![[Pasted image 20231104204217.png]]
*слика 3.*

За крај, треба succ врската на јазoлот A да покажува кон соседот на Б, и pred врската на јазолот Б да покажува кон соседот на А. Со тоа го решаваме проблемот на врските што беа обележани со црвено во *слика 2.*

![[Pasted image 20231104204744.png]]
*слика 4.*

Ова е финалниот изглед на листата. Овој начин на решавање би паднал ако војникот Б се јавува пред војникот А, но е доволно добар за да поминат сите дадени тест примери :D

Временска сложеност: O(n)
Просторна сложеност: O(n)

## Задача 2
За дадена низа од стрингови, треба да најдеме колку парови може да образуваме од зборови кои почнуваат на истата буква. Ќе чуваме низа од 26 цели броеви - за секоја буква од латиницата.

Исто така, ќе чуваме и променлива за резултатот, која треба да биде иницијализирана на 0.

Ја изминуваме низата стрингови и во секоја итерација:
1. Проверуваме колку зборови досега сме сретнале кои почнуваат на таа буква;
2. Тој број го додаваме на резултатот, бидејќи толку нови парови може да се формираат;
3. Го инкрементираме бројачот за таа конкретна буква.

Hint: *Character.getNumericValue(char c)* е методот кој се користи за конвертирање char во int, за да може да вршиме операции врз карактерите како во C/C++.

Временска сложеност: O(n)
Просторна сложеност: O(n)
## Задача 3
За оваа задача клучното е да ги замислиме глувците и дупките, со нивните позиции, на една оска. 
Може да забележиме дека, ако ги подредиме глувците и дупките по позиција, секогаш ќе биде оптимално првиот глушец да влезе во првата дупка, вториот во втората, итн.

На пример, да замислиме глувци на 0 и 3, и дупки на 2 и 5. Иако на глушецот на позиција 3 би му било поблиску да влезе во дупката на позиција 2, тоа не би било оптималното решение. Така на глушецот на позиција 0 би му требале, покрај двете минути за да стигне до стартната позиција на другиот, **уште 3 минути (кои другиот глушец и онака би ги потрошил паралелно со него)** за да стигне до дупката на позиција 5.

Временска сложеност: O(nlogn) - имаме сортирање
Просторна сложеност: O(n)
