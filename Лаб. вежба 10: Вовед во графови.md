## Задача 1

**НАПОМЕНА: следува објаснување за имплементацијата на неориентиран нетежински граф со листа на соседство, која е веќе дадена како генеричка класа во кодовите од аудиториски вежби.**

Неориентиран нетежински граф со листа на соседство е податочна структура која во себе содржи одреден број на листи/колекции кои го претставуваат множеството соседи на секое од темињата во графот.

За пример да ја видиме репрезентацијата на 

![image](https://github.com/afilipovski/APS-labs-2023-24/assets/69673676/5674e6f3-1153-49bf-90ca-27cc554438c1)


| јазол |            |     |
|-------|------------|-----|
| 1     | има соседи | 2,3 |
| 2     | има соседи | 1,3 |
| 3     | има соседи | 1,2 |

Според табелата очигледно е дека оваа структура може да се имплементира со хеш табела, која како клуч ќе прима еден јазол, а вредноста која ќе одговара на него ќе биде некаква колекција од јазли.

Прашањето е, каква колекција би била најсоодветна? Не би имало смисла даден јазол да го има истиот јазол како сосед два пати, така што би било добро да искористиме некаков тип на множество. Дополнително, од разгледување на тест случаите може да забележиме дека ниту редоследот на додавање, ниту вредноста на јазолот не го диктираат редоследот на печатење. Така што, вредноста на хеш табелата може да биде `HashSet`.

Останатиот дел од имплементацијата е едноставна:

`CREATE`: го повикуваме конструкторот на графот и го зачувуваме новиот објект. $O(1)$ операција.

`ADDEDGE A B`: проверуваме дали има ставка за A и B во хеш табелата, и ако нема ги создаваме. Потоа го додаваме B во множеството соседи на A, и A во множеството соседи на B. $O(1)$.

`DELETEEDGE A B`: го отстрануваме B од множеството соседи на A, и A од множеството соседи на B. $O(1)$ (користиме `HashSet`).

`ADJACENT A B`: проверуваме дали B го има во множеството соседи на A. Обратното е еквивалентно. $O(1)$ (користиме `HashSet`).

`PRINTGRAPH`: за секој клуч X во хеш табелата која го репрезентира графот, печатиме *X: `adjList.get(X).toString()`* (форматот на вредноста од хеш табелата кој се бара во тест примерите е default-от од toString методот на HashSet). $O(N^2)$ операција (најлошиот случај е сите да граничат со сите: $N\cdot(N-1)=N^2-N$ операции).
 
Временска сложеност: $O(KN^2)$, каде K е број на команди, N е број на јазли. (најлош случај секоја команда да биде печатење граф)

Просторна сложеност: $O(N^2)$ (најлош случај $N\cdot(N-1)=N^2-N$ елементи во множествата)

## Задача 2

Од кодовите од аудиториски вежби потребно е да се прошири имплементацијата на класата `AdjacencyMatrixGraph<T>` и да се модифицира кодот во класата `Maze` за да се овозможи наоѓање на најкраток пат низ совршен лавиринт.

Во класата `Maze` го менуваме кодот каде се употребува `AdjacencyListGraph<T>` и ги повикуваме истоимените функции од `AdjacencyMatrixGraph<T>`. Имплементација на матрица со соседство побарува секој јазол во графот да има свој индекс. За јазол на позиција `(i, j)` во лавиринт со димензии `m x n` може да се користи индексот `index = n * i + j`.

Дополнително, потребно е да се имплементира функцијата `findPath` во графот со матрица на соседство, што се прави на сличен начин како и дадената имплементација на истоимената функција во класата `AdjacencyListGraph<T>`. Останатите функции се модифицираат по потреба.

Во најлош случај секое поле на `m x n` гридот ќе треба да се додаде во графот и притоа е потребно уште едно изминување на јазлите за да се најде патот помеѓу почетниот и крајниот јазол. Ако тоа е така, сложеноста на алгоритмот зависи само од димензиите на дадениот грид.

Временска сложеност: $O(MN)$\
Просторна сложеност: $O(MN)$
