## Задача 2

Го изминуваме влезот на задачата, и за паровите од македонски и англиски збор, ја земаме целата редица и ја делиме со `s.split(" ")` на одделни токени.

Во вака добиената низа од стрингови, на индекс 0 ни се наоѓа македонскиот, а на индекс 1 англискиот збор.

Во `OBHT` хеш табела деловите од редот ги внесуваме како пар клуч и вредност (клуч ќе ни биде англискиот, а вредност македонскиот збор, бидејќи ќе бараме македонски збор за даден англиски).

Потоа, ги изминуваме следните редови се' додека не стигнеме до *KRAJ*. За секој прочитан збор, со `obht.search(en)` го наоѓаме бројот на кофичката каде се наоѓа потребниот клуч-вредност пар. Доколку оваа функција ни врати -1, значи дека бараниот збор го немаме во хеш табелата и печатиме `/`. Инаку, со `obht.getBucket(index).value` го земаме македонскиот збор и го печатиме на излез.

Временска сложеност: $O(n)$

Просторна сложеност: $O(n)$

## Задача 3

Едно решение за симулирањето на рутирање преку хеш табела, при што за секој рутер одговара единствена кофичка во хеш табелата, се прави со воведување на клуч-вредност парови од тип `(String, List<String>)`.
#### Прв дел: Ажурирање на хеш табелата

Првично потребно е да се додадат информациите за рутерите во хеш табелата. За таа цел, секоја кофичка ќе биде идентификувана со рутирачката IP адреса, а како резултат ќе враќа листа од сите IP адреси кои може да ги достапи.

Со `for` циклус, за секој рутер ја пополнуваме хеш табелата на следниот начин:
1. Ако за даден рутер нема доделена кофичка од хеш табелата, во истата ставаме празна листа; `hashMap.putIfAbsent(routerIP, new ArrayList<>())`.
2. Ја преземаме соодветната листа и ги додаваме дестинациските IP адреси во истата; `hashMap.get(routerIP).addAll(routerDestinations)`.
или
1. Ако знаеме дека рутерот никогаш не бил додаден во табелата, може директно да ги додадеме дестинациските адреси; `hashMap.put(routerIP, routerDestinations)`.

**Напомена:** Конструкцијата `hashMap.putIfAbsent(...)` во склоп со `hashMap.get(...)` често се користи кога не сакаме да ја пребришеме прво-додадената ставка, која најчесто е некаква колекција (како листа). Од друга страна, функцијата `hashMap.put(...)` ги пребришува соодветните ставки.

(Имплицитно знаеме дека ако имаме IP адреса со 24 битна мрежна маска, рутерот кој може да испрати пакет до друг рутер со IP адреса `x.y.z.w/24`, дополнително може и да достапи до соодветната broadcast адреса, т.е. `x.y.z.0/24`.)

#### Втор дел: Пребарување низ хеш табелата

За да откриеме дали постои рута до одредена дестинациска IP адреса, проверуваме дали изворниот рутер постои во нашата хеш табела. Во потврден случај ја преземаме листата од дестинациски рути и ја повикуваме функцијата `contains` на таа листа. Во зависност од тоа дали дестинациската IP адреса се наоѓа во листата, печатиме соодветно `postoi` или `ne postoi`.

Временска сложеност: $O(nk)$ \
Мемориска сложеност: $O(nk)$

каде $n$ е бројот на изворни рутери, а $k$ е најголемиот број на можни дестинациски рути за даден изворен рутер.


## Задача 4

Во `LekKluch` класата го имплементираме `hashCode` методот како што е специфицирано во текстот. Пожелно е во `hashCode` да се конвертира стрингот во *lowercase* пред да се пресмета хешот, за да се избегнат разликите помеѓу инпутот во првите N редици и нарачките. 

Во `main` методот, повторно пуштаме `for` циклус од 0 до N-1, и за секој следен ред од инпутот, го делиме стрингот на токени со `s.split(" ")`. Четирите делови ни се името на лекот, број 0/1 кој означува дали тој е на позитивна листа (`Integer.parseInt(br)` за претворање од стринг во цел број), цена и количина. Инстанцираме објект од типот `LekKluch` со конструкторот кој прима само име на лек, како и објект од типот `Lek` со конструкторот кој ги прима сите споменати податоци.

Во `CBHT` хеш табелата, внесуваме клуч-вредност пар, каде клуч е `LekKluch` објектот, а вредност е `Lek` објектот.

Почнуваме да читаме два по два реда. Важно е дека доколку при читање на првиот ред наидеме на *KRAJ* треба да се прекине циклусот. Инаку, ги земаме двата реда. Првиот ни го означува името на лекот, а вториот количината која треба да се купи. Со `l.setKolicina(l.getKolicina()-naracka)` ја намалуваме количината на лекот при успешна нарачка. Секако, треба да се провери и дали лекот е достапен во доволна количина за да се спроведе нарачката.

Временска сложеност: $O(n)$

Просторна сложеност: $O(n)$
