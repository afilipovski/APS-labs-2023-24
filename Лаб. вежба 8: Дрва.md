## Задача 1

За потребите за имплементација на Windows Explorer во оваа задача се користи SLL дрво. Иницијализираме ново дрво и согласно барањата на задачата, користејќи ја функцијата `makeRoot` го поставуваме коренот именуван како `c:`. Овој фолдер е и тековниот во кој се наоѓаме. Го означуваме истиот со променлива `currentNode`.

Ги вчитуваме командите соодветно од дадениот влез. Ја имплементираме функционалноста на командите согласно следната логика:

**CREATE \<name\>**: Додаваме јазол-дете на `currentNode`. Ако `currentNode` нема деца, новиот јазол може да го додадеме со функцијата `addChild`. Во спротивно итеративно ги разгледуваме децата-јазли на `currentNode`, застанувајќи пред оној јазол чие што лексикографско име е поголемо од `<name>`. Соодветно, ги ажурираме врските на јазелот што го додаваме, со јазелот претходник (доколку постои) и јазелот следбеник (доколку постои).

**OPEN \<name\>**: Го пребаруваме бараниот јазол преку неговото име во децата-јазли на `currentNode`. Ако го пронајдеме, `currentNode` ја добива вредноста на новиот јазол.

**DELETE \<name\>**: Го пребаруваме бараниот јазол преку неговото име во децата-јазли на `currentNode`. Ако го пронајдеме, ја повикуваме функцијата `remove` од даденото дрво и го отстрануваме јазолот.

**BACK**: Ја менуваме вредноста на тековниот јазол со онаа на јазол-родител, т.е. `currentNode = currentNode.parent`.

**PATH**: Едно можно решение е користејќи `Stack<String>` структура, да ги додаваме сите јазли од тековната датотека до коренот на дрвото. На овој начин, со секое вадење на елементи од стекот, може да ја изградиме апсолутната патека на јазолот. 

*Напомена:* Внимавај да не ја изгубиш информацијата за позицијата на тековниот директориум. Направи копија од променливата `currentNode`.

**PRINT**: Се повикува функцијата `printTree` од даденото дрво.

Сложеноста на овие операции зависи од нивната имплементација, како и од бројот на јазли во дрвото.


## Задача 2

Да се потсетиме дека *preorder* изминување на дрвото подразбира дека секој јазол прво го посетуваме (т.е. во овој случај, печатиме), потоа истото го правиме за коренот на неговото лево поддрво, а на крај за коренот на неговото десно поддрво.

![image](https://github.com/afilipovski/APS-labs-2023-24/assets/69673676/90e663e5-c6e9-454d-ac54-b8aa1449294c)

На сликата го имаме дрвото од првиот тест пример прикажано графички. Почнуваме со изминување од коренот А. За да го изминеме дрвото без рекурзија ќе користиме стек. Пример:
```
* Вадиме А од стек и печатиме.
* Додаваме Е и B на стек
* Стек: [B,E]

* Вадиме B од стек и печатиме.
* Додаваме D и C на стек
* Стек: [C,D,E]

* Вадиме C од стек и печатиме.
* Стек: [D,E]

* Вадиме D од стек и печатиме.
* Стек: [E]

* Вадиме E од стек и печатиме.
* Додаваме F на стек
* Стек: [F]

* Вадиме F од стек и печатиме.
* Додаваме H и G на стек
* Стек: [G,H]

* Вадиме G од стек и печатиме.
* Стек: [E]

* Вадиме E од стек и печатиме.
* Стек: []
```

Стекот е празен. Програмата прекинува. Редоследот на печатење е `A B C D E F G H`. Успешно го искористивме last in - first out својството на стекот за да го одложиме изминувањето на десните деца на јазлите.

Временска сложеност: $O(n)$

Просторна сложеност: $O(n)$
